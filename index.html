// ------------------ GLOBAL ------------------
let files = [];
let results = [];

// ------------------ FILE SELECT ------------------
document.getElementById("files").addEventListener("change", e => {
    files = Array.from(e.target.files);
    document.getElementById("fileInfo").textContent = files.length + " files selected";
    document.getElementById("processBtn").disabled = files.length === 0;
});

// ------------------ PROCESS ALL FILES ------------------
async function processAllFiles() {
    results = [];
    document.getElementById("downloadBtn").style.display = "none";

    for (let i = 0; i < files.length; i++) {
        updateProgress(i + 1, files.length);

        const data = await parseCSV(files[i]);
        const metrics = extractMetrics(files[i].name, data);
        results.push(metrics);
    }

    showResults();
    document.getElementById("downloadBtn").style.display = "inline-block";
}

// ------------------ PROGRESS BAR ------------------
function updateProgress(count, total) {
    const pct = Math.round((count / total) * 100);
    document.getElementById("progress").innerHTML =
        `<div class="progress"><div class="progress-bar" style="width:${pct}%">${pct}%</div></div>`;
}

// ------------------ CSV PARSER ------------------
function parseCSV(file) {
    return new Promise(resolve => {
        Papa.parse(file, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: r => resolve(r.data)
        });
    });
}

// ------------------------------------------------------------
//               MAIN EXTRACTION LOGIC (FIXED)
// ------------------------------------------------------------
function extractMetrics(filename, data) {

    const id = filename.replace(/\.(csv|txt)$/i, "").trim();
    const name = id;

    // Helper finder
    const findRow = label =>
        data.find(r => String(r.Period).toLowerCase().includes(label));

    // Required rows
    const base = findRow("task0");
    const cond = findRow("task1");

    // Counterconditioning rows
    const counterRows = data.filter(r =>
        String(r.Period).toLowerCase().startsWith("task5part")
    );

    const pgq = findRow("task7");

    // Helper to extract metric by partial column name
    function metric(row, key) {
        if (!row) return "N/A";
        const col = Object.keys(row).find(k =>
            k.toLowerCase().includes(key.toLowerCase())
        );
        return row[col] ?? "N/A";
    }

    // Compute mean for counterconditioning across 5 parts
    function meanOf(rows, key) {
        if (!rows.length) return "N/A";
        const vals = rows
            .map(r => metric(r, key))
            .filter(v => typeof v === "number" && !isNaN(v));
        if (!vals.length) return "N/A";
        return vals.reduce((a, b) => a + b, 0) / vals.length;
    }

    return {
        id,
        name,

        base: {
            scl: metric(base, "mean scl"),
            scr: metric(base, "mean scr"),
            freq: metric(base, "scr freq"),
            total: metric(base, "total scr"),
            slope: metric(base, "slope"),
            ns: metric(base, "ns-scl"),
            sclstd: metric(base, "scl std"),
            scrstd: metric(base, "scr std"),
        },

        cond: {
            scl: metric(cond, "mean scl"),
            scr: metric(cond, "mean scr"),
            freq: metric(cond, "scr freq"),
            total: metric(cond, "total scr"),
            slope: metric(cond, "slope"),
            ns: metric(cond, "ns-scl"),
            sclstd: metric(cond, "scl std"),
            scrstd: metric(cond, "scr std"),
        },

        counter: {
            scl: meanOf(counterRows, "mean scl"),
            scr: meanOf(counterRows, "mean scr"),
            freq: meanOf(counterRows, "scr freq"),
            total: meanOf(counterRows, "total scr"),
            slope: meanOf(counterRows, "slope"),
            ns: meanOf(counterRows, "ns-scl"),
            sclstd: meanOf(counterRows, "scl std"),
            scrstd: meanOf(counterRows, "scr std"),
        },

        pgq: {
            scl: metric(pgq, "mean scl"),
            scr: metric(pgq, "mean scr"),
            freq: metric(pgq, "scr freq"),
            total: metric(pgq, "total scr"),
            slope: metric(pgq, "slope"),
            ns: metric(pgq, "ns-scl"),
            sclstd: metric(pgq, "scl std"),
            scrstd: metric(pgq, "scr std"),
        }
    };
}

// ------------------------------------------------------------
//                 PREVIEW TABLE (FIXED)
// ------------------------------------------------------------
function showResults() {
    let html = `
    <h3>Preview (first 10 rows)</h3>
    <table>
        <thead>
            <tr>
                <th>ID</th><th>Name</th>

                <th>SCL Base</th><th>SCL Cond</th><th>SCL Counter</th><th>SCL PGQ</th>
                <th>SCR Base</th><th>SCR Cond</th><th>SCR Counter</th><th>SCR PGQ</th>

                <th>Freq Base</th><th>Freq Cond</th><th>Freq Counter</th><th>Freq PGQ</th>
                <th>Total Base</th><th>Total Cond</th><th>Total Counter</th><th>Total PGQ</th>

                <th>Slope Base</th><th>Slope Cond</th><th>Slope Counter</th><th>Slope PGQ</th>
                <th>NS Base</th><th>NS Cond</th><th>NS Counter</th><th>NS PGQ</th>

                <th>SCL Std Base</th><th>SCL Std Cond</th><th>SCL Std Counter</th><th>SCL Std PGQ</th>
                <th>SCR Std Base</th><th>SCR Std Cond</th><th>SCR Std Counter</th><th>SCR Std PGQ</th>
            </tr>
        </thead><tbody>
    `;

    results.slice(0, 10).forEach(r => {
        html += `
        <tr>
            <td>${r.id}</td><td>${r.name}</td>

            <td>${r.base.scl}</td><td>${r.cond.scl}</td><td>${r.counter.scl}</td><td>${r.pgq.scl}</td>
            <td>${r.base.scr}</td><td>${r.cond.scr}</td><td>${r.counter.scr}</td><td>${r.pgq.scr}</td>

            <td>${r.base.freq}</td><td>${r.cond.freq}</td><td>${r.counter.freq}</td><td>${r.pgq.freq}</td>
            <td>${r.base.total}</td><td>${r.cond.total}</td><td>${r.counter.total}</td><td>${r.pgq.total}</td>

            <td>${r.base.slope}</td><td>${r.cond.slope}</td><td>${r.counter.slope}</td><td>${r.pgq.slope}</td>
            <td>${r.base.ns}</td><td>${r.cond.ns}</td><td>${r.counter.ns}</td><td>${r.pgq.ns}</td>

            <td>${r.base.sclstd}</td><td>${r.cond.sclstd}</td><td>${r.counter.sclstd}</td><td>${r.pgq.sclstd}</td>
            <td>${r.base.scrstd}</td><td>${r.cond.scrstd}</td><td>${r.counter.scrstd}</td><td>${r.pgq.scrstd}</td>
        </tr>`;
    });

    html += "</tbody></table>";
    document.getElementById("results").innerHTML = html;
}

// ------------------------------------------------------------
//                 DOWNLOAD CSV (unchanged)
// ------------------------------------------------------------
function downloadCSV() {
    const header = [
        "ID", "Name",
        "SCL Base","SCL Cond","SCL Counter","SCL PGQ",
        "SCR Base","SCR Cond","SCR Counter","SCR PGQ",
        "Freq Base","Freq Cond","Freq Counter","Freq PGQ",
        "Total Base","Total Cond","Total Counter","Total PGQ",
        "Slope Base","Slope Cond","Slope Counter","Slope PGQ",
        "NS Base","NS Cond","NS Counter","NS PGQ",
        "SCL Std Base","SCL Std Cond","SCL Std Counter","SCL Std PGQ",
        "SCR Std Base","SCR Std Cond","SCR Std Counter","SCR Std PGQ"
    ];

    const rows = results.map(r => [
        r.id, r.name,
        r.base.scl, r.cond.scl, r.counter.scl, r.pgq.scl,
        r.base.scr, r.cond.scr, r.counter.scr, r.pgq.scr,
        r.base.freq, r.cond.freq, r.counter.freq, r.pgq.freq,
        r.base.total, r.cond.total, r.counter.total, r.pgq.total,
        r.base.slope, r.cond.slope, r.counter.slope, r.pgq.slope,
        r.base.ns, r.cond.ns, r.counter.ns, r.pgq.ns,
        r.base.sclstd, r.cond.sclstd, r.counter.sclstd, r.pgq.sclstd,
        r.base.scrstd, r.cond.scrstd, r.counter.scrstd, r.pgq.scrstd
    ]);

    const csv = [header, ...rows].map(r => r.join(",")).join("\n");

    const link = document.createElement("a");
    link.href = URL.createObjectURL(new Blob([csv], { type: "text/csv" }));
    link.download = "EDA_MASTER_SHEET.csv";
    link.click();
}
