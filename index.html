<script>
let files = [];
let results = [];

/* ---------------- FILE SELECTION ---------------- */
document.getElementById("files").addEventListener("change", e => {
    files = Array.from(e.target.files);
    document.getElementById("fileInfo").textContent = `${files.length} files selected`;
    document.getElementById("processBtn").disabled = files.length === 0;
});

/* ---------------- MAIN PROCESSOR ---------------- */
async function processAll() {
    results = [];
    document.getElementById("downloadBtn").style.display = "none";

    for (let i = 0; i < files.length; i++) {
        updateProgress(i + 1, files.length);
        const data = await parseCSV(files[i]);
        const metrics = extractMetrics(files[i].name, data);
        results.push(metrics);
    }

    showResults();
    document.getElementById("downloadBtn").style.display = "inline-block";
}

function updateProgress(count, total) {
    const pct = Math.round((count / total) * 100);
    document.getElementById("progress").innerHTML =
        `<p>Processing ${count}/${total} (${pct}%)</p>`;
}

/* ---------------- CSV PARSER ---------------- */
function parseCSV(file) {
    return new Promise(resolve => {
        Papa.parse(file, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: r => resolve(r.data)
        });
    });
}

/* ---------------- METRIC EXTRACTOR ---------------- */
function extractMetrics(filename, data) {

    const id = filename.replace(/\.(csv|txt)$/i, "").replace("_period_analysis_summary", "");
    const name = id;

    // remove duration column
    data = data.map(r => { if (r) delete r.Duration; return r; });

    /* ---- PHASE DETECTION RULES ---- */

    const baseline = data.find(r =>
        String(r.Period).toLowerCase().includes("task 0")
    );

    const retrieval = data.find(r =>
        String(r.Period).toLowerCase().includes("task 1")
    );

    const counterParts = data.filter(r =>
        String(r.Period).toLowerCase().includes("task5-part")
    );

    const pgq = data.find(r =>
        String(r.Period).toLowerCase().includes("task 7")
    );

    /* ---- Helpers ---- */

    function findColumn(row, key) {
        if (!row) return null;
        return Object.keys(row).find(c => c.toLowerCase().includes(key.toLowerCase()));
    }

    function metric(row, key) {
        if (!row) return "N/A";
        const col = findColumn(row, key);
        return col ? row[col] : "N/A";
    }

    function meanMetric(rows, key) {
        if (!rows || rows.length === 0) return "N/A";
        const col = findColumn(rows[0], key);
        if (!col) return "N/A";
        const values = rows.map(r => Number(r[col]) || 0);
        return (values.reduce((a, b) => a + b, 0) / values.length).toFixed(6);
    }

    return {
        id, name,

        baseline: {
            meanSCL: metric(baseline, "mean scl"),
            meanSCR: metric(baseline, "mean scr"),
            scrFreq: metric(baseline, "freq"),
            totalSCR: metric(baseline, "total"),
            sclSlope: metric(baseline, "slope"),
            nsSCL: metric(baseline, "ns-scl"),
            sclStd: metric(baseline, "scl std"),
            scrStd: metric(baseline, "scr std")
        },

        retrieval: {
            meanSCL: metric(retrieval, "mean scl"),
            meanSCR: metric(retrieval, "mean scr"),
            scrFreq: metric(retrieval, "freq"),
            totalSCR: metric(retrieval, "total"),
            sclSlope: metric(retrieval, "slope"),
            nsSCL: metric(retrieval, "ns-scl"),
            sclStd: metric(retrieval, "scl std"),
            scrStd: metric(retrieval, "scr std")
        },

        counter: {
            meanSCL: meanMetric(counterParts, "mean scl"),
            meanSCR: meanMetric(counterParts, "mean scr"),
            scrFreq: meanMetric(counterParts, "freq"),
            totalSCR: meanMetric(counterParts, "total"),
            sclSlope: meanMetric(counterParts, "slope"),
            nsSCL: meanMetric(counterParts, "ns-scl"),
            sclStd: meanMetric(counterParts, "scl std"),
            scrStd: meanMetric(counterParts, "scr std")
        },

        pgq: {
            meanSCL: metric(pgq, "mean scl"),
            meanSCR: metric(pgq, "mean scr"),
            scrFreq: metric(pgq, "freq"),
            totalSCR: metric(pgq, "total"),
            sclSlope: metric(pgq, "slope"),
            nsSCL: metric(pgq, "ns-scl"),
            sclStd: metric(pgq, "scl std"),
            scrStd: metric(pgq, "scr std")
        }
    };
}

/* ---------------- PREVIEW TABLE ---------------- */
function showResults() {
    let html = `
    <h3>Preview (first 10 rows)</h3>
    <table>
    <thead>
    <tr>
        <th>ID</th><th>Name</th>

        <th>SCL Base</th><th>SCL Retrieval</th><th>SCL Counter</th><th>SCL PGQ</th>

        <th>SCR Base</th><th>SCR Retrieval</th><th>SCR Counter</th><th>SCR PGQ</th>

        <th>Freq Base</th><th>Freq Retrieval</th><th>Freq Counter</th><th>Freq PGQ</th>

        <th>Total Base</th><th>Total Retrieval</th><th>Total Counter</th><th>Total PGQ</th>

        <th>Slope Base</th><th>Slope Retrieval</th><th>Slope Counter</th><th>Slope PGQ</th>

        <th>NS Base</th><th>NS Retrieval</th><th>NS Counter</th><th>NS PGQ</th>

        <th>SCL Std Base</th><th>SCL Std Retrieval</th><th>SCL Std Counter</th><th>SCL Std PGQ</th>

        <th>SCR Std Base</th><th>SCR Std Retrieval</th><th>SCR Std Counter</th><th>SCR Std PGQ</th>
    </tr></thead><tbody>
    `;

    results.slice(0, 10).forEach(r => {
        html += `
        <tr>
            <td>${r.id}</td>
            <td>${r.name}</td>

            <td>${r.baseline.meanSCL}</td><td>${r.retrieval.meanSCL}</td><td>${r.counter.meanSCL}</td><td>${r.pgq.meanSCL}</td>

            <td>${r.baseline.meanSCR}</td><td>${r.retrieval.meanSCR}</td><td>${r.counter.meanSCR}</td><td>${r.pgq.meanSCR}</td>

            <td>${r.baseline.scrFreq}</td><td>${r.retrieval.scrFreq}</td><td>${r.counter.scrFreq}</td><td>${r.pgq.scrFreq}</td>

            <td>${r.baseline.totalSCR}</td><td>${r.retrieval.totalSCR}</td><td>${r.counter.totalSCR}</td><td>${r.pgq.totalSCR}</td>

            <td>${r.baseline.sclSlope}</td><td>${r.retrieval.sclSlope}</td><td>${r.counter.sclSlope}</td><td>${r.pgq.sclSlope}</td>

            <td>${r.baseline.nsSCL}</td><td>${r.retrieval.nsSCL}</td><td>${r.counter.nsSCL}</td><td>${r.pgq.nsSCL}</td>

            <td>${r.baseline.sclStd}</td><td>${r.retrieval.sclStd}</td><td>${r.counter.sclStd}</td><td>${r.pgq.sclStd}</td>

            <td>${r.baseline.scrStd}</td><td>${r.retrieval.scrStd}</td><td>${r.counter.scrStd}</td><td>${r.pgq.scrStd}</td>
        </tr>`;
    });

    html += "</tbody></table>";
    document.getElementById("results").innerHTML = html;
}

/* ---------------- CSV DOWNLOAD ---------------- */
function downloadCSV() {
    const headers = [
        "ID","Name",

        "SCL Base","SCL Retrieval","SCL Counter","SCL PGQ",
        "SCR Base","SCR Retrieval","SCR Counter","SCR PGQ",

        "Freq Base","Freq Retrieval","Freq Counter","Freq PGQ",

        "Total Base","Total Retrieval","Total Counter","Total PGQ",

        "Slope Base","Slope Retrieval","Slope Counter","Slope PGQ",

        "NS Base","NS Retrieval","NS Counter","NS PGQ",

        "SCL Std Base","SCL Std Retrieval","SCL Std Counter","SCL Std PGQ",

        "SCR Std Base","SCR Std Retrieval","SCR Std Counter","SCR Std PGQ"
    ];

    const rows = results.map(r => [
        r.id, r.name,

        r.baseline.meanSCL, r.retrieval.meanSCL, r.counter.meanSCL, r.pgq.meanSCL,
        r.baseline.meanSCR, r.retrieval.meanSCR, r.counter.meanSCR, r.pgq.meanSCR,

        r.baseline.scrFreq, r.retrieval.scrFreq, r.counter.scrFreq, r.pgq.scrFreq,

        r.baseline.totalSCR, r.retrieval.totalSCR, r.counter.totalSCR, r.pgq.totalSCR,

        r.baseline.sclSlope, r.retrieval.sclSlope, r.counter.sclSlope, r.pgq.sclSlope,

        r.baseline.nsSCL, r.retrieval.nsSCL, r.counter.nsSCL, r.pgq.nsSCL,

        r.baseline.sclStd, r.retrieval.sclStd, r.counter.sclStd, r.pgq.sclStd,

        r.baseline.scrStd, r.retrieval.scrStd, r.counter.scrStd, r.pgq.scrStd
    ]);

    const csv = [headers, ...rows].map(r => r.join(",")).join("\n");

    const a = document.createElement("a");
    a.href = URL.createObjectURL(new Blob([csv], { type: "text/csv" }));
    a.download = "EDA_MASTER_SHEET.csv";
    a.click();
}
</script>
